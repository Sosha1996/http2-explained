# ۲. HTTP امروز

HTTP 1.1 تبدیل به پرتکولی شد که مجازاً برای همه‌ی تعاملات در اینترنت استفاده می‌شود. سرمایه‌گذاری‌های عظیم در این پرتکول شده و زیرساخت‌هایی که از این پرتکول بهره می‌برند، تا حدی که معمولاً ساختن چیز‌ها بر روی HTTP ساده‌تر از ساختن چیزی نو و مستقل است.

## ۲.۱. HTTP 1.1 عظیم است

هنگامی که HTTP ساخته و به دنیا عرضه شد، احتمالاً به عنوان یک پرتکول ساده و مستقیم ادراک شد، ولی زمان ثابت کرد که این امر صحیح نیست. HTTP 1.0 در استاندارد RFC 1945 یک سند ۶۰ صفحه‌ای است که در سال ۱۹۹۶ میلادی منتشر شد. استاندارد RFC 2616 که HTTP 1.1 را وصف می‌کند، تنها سه سال بعد و در سال ۱۹۹۹ میلادی منتشر شد و حجم آن به طور چشم‌گیری به ۱۷۶ صفحه افزایش یافت. ولی هنگامی که ما در IETF بر روی به‌روز‌رسانی برای این استاندارد کار کردیم، این استاندارد را به ۶ سند تبدیل کردیم و در حاصل، تعداد بیشتری صفحه (که استاندارد RFC 7230 و خانواده‌اش را به‌وجود آورد) را تشکیل داد. به هر حال، HTTP 1.1 یک استاندارد بزرگ و دارای هزاران موارد جزئی، ظرافت‌ها و قسمت های اختیاری است.

## ۲.۲. دنیایی از گزینه‌ها
داشتن جزئیات بیشتر و گزینه‌های دردسترس برای افزونه‌های بعدی، از طبیعت HTTP 1.1 که باعث رشد یک اکوسیستم نرم‌افزاری است که هیچ پیاده‌سازی‌ای، چیز دیگری را پیاده‌سازی نمی‌کند، و حتا تقریباُ غیرممکن است که «چیز» را وصف کرد. این، منجر به شرایطی شد که قابلیت‌هایی که در ابتدا بسیار کم استفاده شدند، کمتر پیاده‌سازی شدند و کسانی که آن‌ها را پیاده‌سازی کردند هم کاربرد کمی در آن‌ها دیدند.

بعدها، هنگامی که کلاینت‌ها و سرورها به چنین قابلیت‌هایی رو آوردند، مشکل همکاری پیش آمد. HTTP Pipelining از مصداق این قابلیت‌هاست.

## ۲.۳. استفاده‌ی ناکافی از TCP

HTTP 1.1 به سختی از همه‌ی قابلیت‌ها و قدرتی که TCP ارائه می‌دهد، استفاده می‌کند. کلاینت‌های HTTP و مرورگرها باید بسیار خلاق باشند تا بتوانند راه‌حل‌هایی برای کاهش زمان بازکردن برگه‌ها بیابند.

تلاش‌های دیگر که به صورت موازی در طول سال‌ها صورت گرفته هم تأیید می‌کند که جایگزینی TCP آسان نیست، به همین دلیل است که ما کارمان را برای بهبود TCP و پرتکول‌های بناشده بر آن ادامه دادیم.

نگران نباشید، TCP را می‌توان برای جلوگیری از توقف‌ها و معطلی‌های بیهوده به کار گرفت تا داده‌های بیشتری ارسال و دریافت شود. قسمت‌های بعدی این بند را توضیح می‌دهد.

## ۲.۴. اندازه‌ی داده‌های مبادله‌شده و تعداد اشیا

هنگامی که به ترند بیشتر وب‌سایت‌های پرطرفدار در وب امروز نگاه می‌کنیم و این‌که چه منابعی را برای نمایش صفحه‌ی اصلی دانلود می‌کنند، یک الگوی واضح نمایان می‌شود. در طول سال‌ها، مقدار داده‌هایی که برای نمایش یک صفحه نیاز است، به ندرت به ۱.۹ مگابایت افزایش پیدا کرده است. چیزی که مهم‌تر است، این است که به‌طور میانگین صد فایل جداگانه برای نمایش هر صفحه نیاز است.

همان‌طور که نمودار زیر نشان می‌دهد، این ترند برای مدتی است که استفاده می‌شود و هیچ نشانه‌ای از این‌که این روند به این زودی تغییر می‌کند، نداریم. این نمودار، رشد اندازه‌ی کلی حجم مبادله‌شده (به رنگ سبز) و تعداد کل درخواست‌ها به صورت میانگین (به رنگ قرمز) در وب‌سایت‌های پرطرفدار جهان است و این‌که آن‌ها چگونه این روند را در ۴ سال گذشته پیش گرفته‌اند.

![transfer size growth](https://raw.githubusercontent.com/bagder/http2-explained/master/images/transfer-size-growth.png)

## ۲.۵. اختلالات تأخیر

<img style="float: right;" src="https://raw.githubusercontent.com/bagder/http2-explained/master/images/page-load-time-rtt-decreases.png" />

HTTP 1.1 بسیار به تأخیر (Latency) حساس است، قسمتی از آن به دلیل این که HTTP piplining هم‌چنان با مشکلاتی رو‌به‌روست که برای تعداد زیادی از کاربران، خاموش بماند.

در حالی که ما افزایش چشم‌گیری در پهنای‌باند در‌دسترس کاربران در چند سال اخیر شاهدیم، ولی در کاهش تأخیر، بهبودی‌های چندانی اعمال نشده است، ارتباط‌هایی با تأخیر زیاد مانند بسیاری از فناوری‌های همراه، داشتن تجربه‌ی یک وب سریع و خوب را سخت می‌کند، حتی اگر شما پهنای‌باند زیادی را در اختیار داشته باشید.

مورد استفاده‌ی دیگری که به تأخیر بسیار پایینی نیاز دارند، نوع خاصی از ویدیوها هستند، مانند کنفرانس ویدیویی، بازی‌های آنلاین و بقیه‌ی موارد مشابه که در آن‌ها یک جریان از‌پیش‌تولید‌شده برای ارسال وجود ندارد.

## ۲.۶. پیشتاز مسدود‌کننده‌ی صف

HTTP Piplining یک راه برای ارسال یک درخواست دیگر، هنگامی که منتظر یک درخواست دیگر هستیم، است. این سیار شبیه به صف‌بندی در یک بانک یا یک سوپرمارکت است. شما نمی‌دانید که پیشتاز صف یک مشتری سریع است یا یک فرد مزاحم که کارش را طول می‌دهد: پیشتاز مسدود‌کننده‌ی صف.

<img style="float: right;" src="https://raw.githubusercontent.com/bagder/http2-explained/master/images/head-of-line-blocking.jpg" />

البته شما می‌توانید در انتخاب صف مراقب باشید و صفی را انتخاب کنید که کارتان زودتر راه بیفتد، یا حتی گاها خودتان یک صف ایجاد کنید، ولی در پایان شما نمی‌توانید از تصمیم‌گیری فرار کنید و هنگامی که تصمیم گرفتید، نمی‌توانید صف‌تان را عوض کنید.

ایجاد یک صف جدید، با مصرف منابع و کاهش کارایی همراه خواهد بود، و در تعداد کمتر صف‌ها، مقیاس‌پذیر نیست. هیچ راه‌حل بی‌نقصی برای این مشکل وجود ندارد.

حتی امروز، در سال ۲۰۱۵، بیشتر مرورگرهای وب، قابلیت HTTP piplining را به طور پیش‌فرض غیرفعال کرده‌اند.

اطلاعات بیشتر در این موضوع را می‌توان به ‌طور مثال در این [گزارش باگ‌زیلا](https://bugzilla.mozilla.org/show_bug.cgi?id=264354) درمورد فایرفاکس پیدا کرد.